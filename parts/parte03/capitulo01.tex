% !TeX root = ../libro.tex
% !TeX encoding = utf8

\setchapterpreamble[c][0.75\linewidth]{%
	\sffamily
  \emph{No debemos creer a quienes hoy, con porte filosófico y tono deliberativo, profetizan la caída de la cultura y aceptan el {\normalfont \sffamily ignorabimus}. Para nosotros no hay {\normalfont \sffamily ignorabimus}, y en mi opinión tampoco lo hay en la ciencia natural. En oposición al necio {\normalfont \sffamily ignorabimus} nuestro lema será: ``¡debemos saber -- sabremos!''}
 \begin{flushright} — David Hilbert, \cite{Vinnikov1999} \end{flushright}
% \\[8pt]
	\par\bigskip
}
%\vspace{28pt}

\chapter{Sistemas lógicos}\label{ch:sistemas-logicos}

En este capítulo, nos preguntamos por si podemos expresar de forma algorítmica los conceptos de \emph{demostración} y \emph{verdad}. Esto es, preguntamos si existe una forma automática de resolver teoremas y comprobar afirmaciones. Como explicamos en el \cref{ch:historia}, este fue uno de los ejes centrales de las matemáticas de principios del siglo \textsc{xx}.

Las matemáticas consisten en deducir teoremas a partir de una cierta lista de axiomas. Para poder definir precisamente este concepto, recurrimos a los \emph{sistemas formales} (\cref{sec:sistemas-formales}).

Sin embargo, nos interesa especialmente saber si las afirmaciones (o \emph{fórmulas}) de un sistema son \emph{verdaderas}. Para esto, necesitaremos definir los \emph{sistemas lógicos} (\cref{sec:sistemas-logicos}).

Una vez realizada la distinción entre \emph{demostrable} y \emph{verdadero}, nos preguntamos por la relación que estos dos conceptos tienen en un determinado sistema lógico: a partir de esto, comprenderemos en la \cref{sec:solidez-completitud-decidibilidad} los conceptos de \emph{solidez} y \emph{completitud}, y finalmente preguntaremos si podemos comprobar si una fórmula es verdadera de forma algorítmica, pudiendo decir si un sistema lógico es \emph{decidible} o no (véase el \cref{ch:problema-parada}). A lo largo de esta sección introduciremos múltiples ejemplos de sistemas lógicos que reforzarán los conceptos ya mencionados, todos girando en torno a una operación aritmética sencilla.

A continuación, introduciremos un sistema lógico de especial importancia: la aritmética de Peano (\cref{sec:aritmetica-peano}). Este sistema es capaz de demostrar una gran cantidad de teoremas de la teoría de números, por lo que nos resultará especialmente interesante saber si todas sus afirmaciones verdaderas son demostrables (este es, justamente, el Primer Teorema de Incompletitud, que demostramos en el \cref{ch:teorema-incompletitud}). Para ello, encontraremos una forma de traducir el problema de parada (\cref{sec:problema-parada}) en una fórmula de este sistema.

Finalmente, introduciremos más propiedades de los sistemas introducidos en la \cref{sec:consistencia}.

\section{Sistemas formales}\label{sec:sistemas-formales}

A lo largo de este trabajo, hemos presentado múltiples demostraciones, pero ¿qué es exactamente una demostración? Cuando hablamos de \emph{demostrar} algo, nos referimos a hacerlo de forma matemática. Al contrario que las pruebas científicas, las pruebas matemáticas son exactas y comprobables. De este modo, podemos preguntarnos si un ordenador puede realizar demostraciones de forma automática.

Para responder a todas estas preguntas, necesitaremos crear una estructura matemática que nos permita formalizar el concepto de \emph{demostración}.

\begin{definicion}[Sistema formal]\label{def:sistema-formal}
\index{sistema formal}
Un \emph{sistema formal}, $\mathcal{S}$, es una tripleta $\mathcal{S} = (\mathcal{L}, \mathcal{A}, \mathcal{R})$, donde:
\begin{itemize}
    \item $\mathcal{L}$ es el \emph{lenguaje formal}\index{lenguaje!formal} sobre un cierto alfabeto $A$. Cada uno de los elementos del lenguaje se denomina \emph{fórmula bien formada} (o \emph{fórmula}).\index{fórmula}\footnote{Siempre que hablamos de \emph{fórmulas} nos referimos a fórmulas bien formadas.}\index{fórmula!bien formada}
    \item $\mathcal{A}$ es el conjunto de \emph{axiomas},\index{axioma} que es un conjunto de fórmulas de $\mathcal{L}$.
    \item $\mathcal{R}$ es el conjunto de \emph{reglas de inferencia},\index{regla de inferencia} que es un conjunto de funciones que mapean fórmulas de $\mathcal{L}$, llamadas \emph{premisas}, en fórmulas de $\mathcal{L}$, llamadas \emph{derivaciones}. Todas las funciones de $\mathcal{R}$ deben ser computables (ver \cref{def:decidible}).

    Si dadas dos fórmulas $\phi_1, \phi_2\in\mathcal{L}$, $\phi_2$ se deriva a partir de $\phi_1$, usaremos la notación $\phi_1 \mapsto \phi_2$. Si $\phi_2$ se deriva a partir de $\phi_1$ en un número finito de derivaciones, usaremos la notación $\phi_1 \xmapsto{*}\phi_2$.
\end{itemize}
\end{definicion}

Veamos un ejemplo de sistema formal que nos será extremadamente útil en este capítulo.

\begin{sistemaformal}[\textbf{SumaBinaria}]\label{sf:suma-binaria}
Sea $\textbf{SumaBinaria}=(\mathcal{L}, \mathcal{A}, \mathcal{R})$ el sistema formal compuesto por:

\begin{itemize}
    \item Lenguaje $\mathcal{L}$: está formado sobre el alfabeto $\{\texttt{0}, \texttt{1}, \texttt{+}, \texttt{=}\}$, y es el reconocido por la expresión regular\footnote{Aquí el símbolo de suma \texttt{+} es un literal, no el operador $+$.}
    $$
        N(\texttt{+}N)^*=N(\texttt{+}N)^*
    $$
    donde $N$ es una abreviatura de la expresión regular $\texttt{1}(\texttt{0}|\texttt{1})^*$.
    \item Conjunto de axiomas $\mathcal{A}$: está formado por un único axioma,
    $$
        \mathcal{A} = \{\texttt{1=1}\}
    $$
    \item Conjunto de reglas de inferencia $\mathcal{R}$: son las siguientes:
    $$
    \begin{matrix}
    \text{(R1)} & A\texttt{=}B & \mapsto & \texttt{1+}A\texttt{=}\texttt{1+}B \\
    \text{(R2)} & A\underline{N}\texttt{+}\underline{N}B & \mapsto & AN\texttt{0}B \\
    \text{(R3)} & A\texttt{\underline{1}+}\underline{N\texttt{0}}B & \mapsto & AN\texttt{1}B
    \end{matrix}
    $$
    donde usamos la siguiente notación: $A$ y $B$ son palabras del alfabeto $\{\texttt{0}, \texttt{1}, \texttt{+}, \texttt{=}\}$ y $N$ es una palabra que obedece la expresión regular $\texttt{1}(\texttt{0}|\texttt{1})^*$. Las partes subrayadas son compilaciones \emph{maximales} de la expresión regular de $N$.
\end{itemize}
\end{sistemaformal}

Es importante recalcar la notación usada para describir las reglas de inferencia de \textbf{SumaBinaria}, en concreto, sobre el significado de \textit{compilación maximal}.\index{compilación maximal} Una compilación maximal, en este caso, es una subcadena que verifica la expresión regular de $N$ y no puede extenderse en más direcciones. En el caso de la fórmula \texttt{100+11+1001=101}, tenemos cuatro compilaciones maximales de este tipo: \texttt{100}, \texttt{11}, \texttt{1001} y \texttt{101}, en ese orden.

Sería posible describir estas reglas mediante expresiones regulares, pero esto haría que la notación fuese menos sencilla e intuitiva.

Una vez definido un sistema formal, será posible probar (o \emph{demostrar}) algunas de sus fórmulas, a las que llamaremos \emph{teoremas}.

\begin{definicion}[Teorema y demostración]\label{def:teorema-demostracion}
\index{teorema}\index{demostración}Dado un sistema formal $\mathcal{S}=(\mathcal{L}, \mathcal{A}, \mathcal{R})$, una \emph{demostración} de una fórmula de $\mathcal{S}$ es una secuencia finita de fórmulas de $\mathcal{S}$, donde cada una de las fórmulas es un axioma, o se sigue de aplicar una regla de inferencia a las fórmulas que aparecen anteriormente en la secuencia.

Una fórmula $\phi\in \mathcal{L}$ se dice \emph{teorema} (o \emph{fórmula demostrable}, o \emph{fórmula probable})\index{fórmula!demostrable}\index{fórmula!probable} si existe una demostración en $\mathcal{S}$.
\end{definicion}

Veamos un ejemplo de teorema en \textbf{SumaBinaria}.

\begin{ejemplo}\label{ej:teorema}
Sea \texttt{1+1+1=11} una fórmula de \textbf{SumaBinaria}. Veamos que es un teorema:

\begin{table}[h]
\centering
\begin{tabular}{lrcl}
& (F1) & \texttt{1=1} & (axioma) \\
$\mapsto$ & (F2) & \texttt{1+1=1+1} & (aplicar R1 a F1) \\
$\mapsto$ & (F3) & \texttt{1+1=10} & (aplicar R2 a F2) \\
$\mapsto$ & (F4) & \texttt{1+1+1=1+10} & (aplicar R1 a F3) \\
$\mapsto$ & (F5) & \texttt{1+1+1=11} & (aplicar R3 a F4) \\
\end{tabular}
\end{table}
\end{ejemplo}

Observa que, aunque no esté en la definición, las demostraciones de los teoremas suelen ir acompañadas de notas que ayudan a comprobar la prueba. En el código de este trabajo se proporciona una función \texttt{suma\_binaria.py} que puede generar demostraciones: \texttt{es\_teorema}. Para probar si una fórmula es un teorema en alguno de los sistemas de este capítulo, especifica el nombre del sistema seguido de la fórmula.

A continuación, algunos ejemplos de uso de esta función:
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_teorema
>>> es_teorema('SumaBinaria', '1+1+1=111')
    (F1) 1=1            (Axioma)
 -> (F2) 1+1=1+1        (R1)
 -> (F3) 1+1+1=1+1+1   (R1)
 -> (F4) 1+1+1=1+10     (R2)
 -> (F5) 1+1+1=11       (R3)
'teorema'
>>> es_teorema('SumaBinaria', '11+1=10')
'no demostrado en las primeras 109322 fórmulas generadas'
>>> es_teorema('SumaBinaria', 'mal-formada')
'fórmula mal formada'
>>> es_teorema('SistemaQueNoExiste', 'lo-que-sea')
'el sistema no existe'
\end{lstlisting}
La prueba de \texttt{1+1+1=111} que realiza \texttt{es\_teorema} es diferente de la del \cref{ej:teorema}. Esto es perfectamente posible: un teorema puede tener diversas demostraciones. Este hecho se evidencia de la propia \cref{def:teorema-demostracion}: una fórmula es un teorema si ``\textit{existe} una demostración''.
\section{Sistemas lógicos}\label{sec:sistemas-logicos}

Como dice el propio nombre, el sistema \textbf{SumaBinaria} pretende comprobar fórmulas de la suma binaria. De este modo, una palabra como \texttt{11} representa el número $3$, y una fórmula como \texttt{1+1+1=11} representa que $1+1+1=3$. Observa que esto nos permite reconocer si una fórmula de \textbf{SumaBinaria} es verdadera: simplemente la interpretamos como si se tratase de una fórmula aritmética, y la declaramos como cierta si es una fórmula aritmética correcta. De este modo, fórmulas como \texttt{10+1=11} son verdaderas, mientras que otras como \texttt{11+1=10} no lo son.

En el apartado anterior, no mencionamos el concepto de \emph{verdad} de forma intencionada: un sistema formal no tiene ninguna noción de certeza. Esto es porque las definiciones de \emph{teorema} y \emph{fórmula verdadera} son completamente diferentes.

Los teoremas solo dependen de la sintaxis:\index{sintaxis} ``¿podemos demostrar un teorema a partir de unos ciertos axiomas y unas reglas de inferencia?'' La verdad, sin embargo, depende de la semántica: ``¿es esta fórmula cierta cuando es interpretada dándole cierto significado a sus símbolos?''.

Por definición, los sistemas formales solo dependen de la sintaxis. En esta sección, introduciremos los \emph{sistemas lógicos}, que no son nada más que sistemas formales a los que le añadimos una \emph{semántica}. Cuando añadimos la semántica de la aritmética que hemos comentado al sistema formal \textbf{SumaBinaria} obtenemos el sistema lógico \textbf{SumaBinariaLógico}.

\begin{sistemalogico}[\textbf{SumaBinariaLógico}]\label{sl:suma-binaria-logico}
Sea \textbf{SumaBinariaLógico} el sistema lógico que se obtiene al añadir la semántica de la aritmética al sistema formal \textbf{SumaBinaria}.

Una fórmula en \textbf{SumaBinariaLógico} es verdadera si es cierta vista como una fórmula aritmética de la suma de números binarios.
\end{sistemalogico}

Formalmente, podemos definir estos sistemas como:

\begin{definicion}[Sistema lógico]\label{def:sistema-logico}
\index{sistema!lógico}Un sistema lógico $\mathcal{G} = (\mathcal{S}, \mathcal{I})$ consiste en un sistema formal $\mathcal{S}=(\mathcal{L}, \mathcal{A}, \mathcal{R})$ y una semántica o \emph{asignación de verdad}\index{asignación de verdad} $\mathcal{I}$, donde $\mathcal{I}$ es una función que asigna a fórmulas de $\mathcal{L}$ una \emph{interpretación},\index{interpretación} que es un valor del conjunto $\{\text{verdadero}, \text{falso}\}$.

La asignación de verdad no debe ser necesariamente computable (\cref{def:decidible}) y puede estar definida para todas las fórmulas o para un subconjunto de ellas.\footnote{Cuando una fórmula no está bien definida o no tiene una interpretación definida, podemos asumir que es falsa.}
\end{definicion}

Una vez que incorporamos a un sistema formal una asignación de verdad, podemos decir cuándo una fórmula es verdadera. Precisamos esto en la definición siguiente:

\begin{definicion}[Fórmula verdadera y fórmula falsa]
\index{fórmula!verdadera}Dado un sistema lógico $\mathcal{G}=(\mathcal{S}, \mathcal{I})$ con $\mathcal{S}=(\mathcal{L}, \mathcal{A}, \mathcal{R})$, decimos que la fórmula $\phi \in \mathcal{S}$ es \emph{verdadera} si $\mathcal{I}(\phi)$ está bien definido y es $\mathcal{I}(\phi)=\text{verdadero}$. En caso contrario, decimos que la fórmula es \emph{falsa}.
\end{definicion}

Veamos ejemplos de fórmulas verdaderas y falsas para \textbf{SumaBinariaLógico}.

\begin{ejemplo}\label{ej:suma-binaria-logico}
Sea \texttt{1+1+1=11} una fórmula de \textbf{SumaBinariaLógico}. Claramente, esta fórmula es verdadera dado que la siguiente operación aritmética es cierta para el sistema de numeración binario:
$$1+1+1=11$$
\end{ejemplo}

En \texttt{suma\_binaria.py} también se proporciona una función para comprobar la veracidad de las fórmulas en sistemas lógicos, llamada \texttt{es\_verdadero}. Un ejemplo:
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_verdadero
>>> es_verdadero('SumaBinariaLógica', '1+1+1=111')
True
>>> es_verdadero('SumaBinariaLógica', '11+1=10')
False
>>> es_verdadero('SumaBinariaLógica', 'mal-formada')
False
>>> es_verdadero('SumaBinaria', '1+1+1=111')
'el sistema no existe o no es un sistema lógico'
\end{lstlisting}
Introduciremos más sistemas lógicos que resultarán de añadir (\cref{sl:suma-binaria-logico-roto}) y eliminar (\cref{sl:suma-binaria-logico-restringido}) reglas de \textbf{SumaBinariaLógico}.

\begin{sistemalogico}[\textbf{SumaBinariaLógicoRoto}]\label{sl:suma-binaria-logico-roto}
Sea \textbf{SumaBinariaLógicoRoto} el sistema lógico que se obtiene al añadir la regla de inferencia siguiente a \textbf{SumaBinariaLógico}:
$$
    \begin{matrix}
    \text{(R1b)} & A\texttt{=}B & \mapsto & \texttt{1+}A\texttt{=}B
    \end{matrix}
    $$
\end{sistemalogico}


\begin{sistemalogico}[\textbf{SumaBinariaLógicoRestringido}]\label{sl:suma-binaria-logico-restringido}
Sea \textbf{SumaBinariaLógicoRestringido} el sistema lógico que se obtiene al eliminar la regla de inferencia (R3) a \textbf{SumaBinariaLógico}.
\end{sistemalogico}
Estos sistemas son especialmente interesantes, pues en ellos podemos encontrar tanto fórmulas demostrables y no verdaderas (\cref{ej:suma-binaria-logico-roto-inconsistente}) como fórmulas verdaderas y no demostrables (\cref{ej:suma-binaria-logico-restringido-incompleto}).

\begin{ejemplo}\label{ej:suma-binaria-logico-roto-inconsistente}
La fórmula \texttt{1+1=1} es un teorema y no es verdadera en \textbf{SumaBinariaLógicoRoto}.

Claramente, $1+1=1$ no una operación cierta de la suma binaria, y por tanto no es una fórmula verdadera. Sin embargo, se trata de un teorema porque podemos demostrarlo directamente a partir del axioma mediante la nueva regla (R1b) introducida.
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_teorema, es_verdadero
>>> es_teorema('SumaBinariaLógicoRoto', '1+1=1')
    (F1) 1=1    (Axioma)
 -> (F2) 1+1=1  (R1b)
'teorema'
>>> es_verdadero('SumaBinariaLógicoRoto', '1+1=1')
False
\end{lstlisting}
\end{ejemplo}

\begin{ejemplo}\label{ej:suma-binaria-logico-restringido-incompleto}
La fórmula \texttt{1+10=11} no es un teorema y es verdadera en \textbf{SumaBinariaLógicoRestringido}.

La fórmula es verdadera dado que $1+10=11$ es una operación correcta en la suma binaria. Sin embargo, no es un teorema porque, al eliminar (R3), no podemos reemplazar los \texttt{0} con \texttt{1}.
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_teorema, es_verdadero
>>> es_teorema('SumaBinariaLógicoRestringido', '1+10=11')
'no demostrado en las primeras 154639 fórmulas generadas'
>>> es_verdadero('SumaBinariaLógicoRestringido', '1+10=11')
True
\end{lstlisting}
Es importante notar que la función \texttt{es\_teorema} no puede demostrar que una fórmula no es demostrable debido a la forma en la que la hemos diseñado. El código anterior no prueba que \texttt{1+10=11} no sea un teorema -- la prueba de este ejemplo sí.
\end{ejemplo}

\section{Solidez, completitud y decidibilidad}\label{sec:solidez-completitud-decidibilidad}

Hemos encontrado sistemas lógicos en los que hay fórmulas verdaderas y no demostrables, y viceversa. Esto nos conduce a la definición de dos importantes propiedades de los sistemas lógicos.

\begin{definicion}[Solidez]\label{def:solidez}
\index{solidez}\index{sistema lógico!sólido}Un sistema lógico es \emph{sólido} si todos sus teoremas son verdaderos. En caso contrario, decimos que es \emph{no sólido}.
\end{definicion}

\begin{definicion}[Completitud]\label{def:completitud}
\index{completitud}\index{completitud!semántica}\index{sistema lógico!completo}\index{sistema lógico!semánticamente completo}\index{completitud!semántica}Un sistema lógico es \emph{(semánticamente) completo}\footnote{Más adelante introducimos la noción de \emph{completitud sintáctica} (\cref{def:completitud-sintactica}). Siempre que llamemos a un sistema \emph{completo}, sin especificar, nos referiremos a su completitud semántica.} si todas las fórmulas verdaderas son teoremas. En caso contrario, decimos que es \emph{incompleto}.
\end{definicion}


Veamos si los sistemas lógicos que hemos presentado hasta ahora son sólidos y completos. Un resumen de todos los resultados se puede ver en la \cref{tab:sistemas-logicos}.

Probar que \textbf{SumaBinariaLógico} es sólido y completo es tedioso: por eso dejamos las demostraciones en el \cref{ap:demostraciones-adicionales}.

\begin{proposicion}
El sistema lógico \normalfont{\textbf{SumaBinariaLógico}} es sólido y completo.
\end{proposicion}
\begin{proof}
La demostración de solidez se prueba en la \cref{prop:ap-cons}, mientras que la de completitud se muestra en la \cref{prop:ap-comp}.
\end{proof}

Dado que los otros sistemas lógicos se ``obtienen'' a partir de \textbf{SumaBinariaLógico}, las proposiciones siguientes son mucho más sencillas de demostrar. Como es evidente, los \cref{ej:suma-binaria-logico-roto-inconsistente,,ej:suma-binaria-logico-restringido-incompleto} prueban que \textbf{SumaBinariaLógicoRoto} es no sólido y que \textbf{SumaBinariaLógicoRestringido} es incompleto, respectivamente.

Veamos a continuación tales proposiciones.

\begin{proposicion}
El sistema lógico \normalfont{\textbf{SumaBinariaLógicoRoto}} es completo y no sólido.
\end{proposicion}
\begin{proof}
Es fácil ver que este sistema es completo a partir de la completitud de \textbf{SumaBinariaLógico}. Observamos que ambos sistemas lógicos tienen la misma sintaxis, es decir, tienen las mismas fórmulas verdaderas. De este modo, una fórmula $\phi$ verdadera en \textbf{SumaBinariaLógico} también lo es en \textbf{SumaBinariaLógicoRoto}.

Veamos si $\phi$ es un teorema en \textbf{SumaBinariaLógicoRoto}. Por la completitud de \textbf{SumaBinariaLógico}, $\phi$ es un teorema en este sistema. Pero como \textbf{SumaBinariaLógicoRoto} tiene todas las reglas de \textbf{SumaBinariaLógico} (y una más), $\phi$ también es un teorema en \textbf{SumaBinariaLógicoRoto}.

Sin embargo, el sistema lógico es no sólido. En el \cref{ej:suma-binaria-logico-roto-inconsistente} vimos una fórmula que es un teorema y no es verdadera.
\end{proof}

\begin{proposicion}
El sistema lógico \normalfont{\textbf{SumaBinariaLógicoRestringido}} es incompleto y sólido.
\end{proposicion}
\begin{proof}
La incompletitud de este sistema se sigue del \cref{ej:suma-binaria-logico-restringido-incompleto}. La solidez se sigue de la solidez de \textbf{SumaBinariaLógico}.

Sea $\phi$ un teorema de \textbf{SumaBinariaLógicoRestringido}. Como \textbf{SumaBinariaLógico} tiene todas las reglas de \textbf{SumaBinariaLógicoRestringido} (y una más), $\phi$ es un teorema en \textbf{SumaBinariaLógico}. De la completitud de \textbf{SumaBinariaLógico}, $\phi$ es verdadero. Pero como \textbf{SumaBinariaLógicoRestringido} tiene la misma sintaxis, $\phi$ también será verdadero en este sistema.
\end{proof}

Los sistemas lógicos \textbf{SumaBinariaLógicoRoto} y \textbf{SumaBinariaLógicoRestringido} los obtuvimos modificando la sintaxis de \textbf{SumaBinariaLógico}. Introducimos ahora el último sistema de este tipo, que surge de modificar la semántica de \textbf{SumaBinariaLógicoRoto}.

\begin{sistemalogico}[\textbf{SumaBinariaLógicoArreglado}]\label{sl:suma-binaria-logico-arreglado}
Sea \textbf{SumaBinariaLógicoArreglado} el sistema lógico que se obtiene a partir de \textbf{SumaBinariaLógicoRoto} modificando su semántica. Interpretaremos las fórmulas como fórmulas aritméticas de la suma de números binarios, pero el símbolo \texttt{=} será interpretado como ``mayor o igual que'' ($\geq$).
\end{sistemalogico}

En este último sistema lógico podríamos haber modificado el símbolo \texttt{=} por \texttt{>=}. Sin embargo, no lo hacemos de forma intencionada, y para recordar que la sintaxis y la semántica son independientes -- podemos asignar el valor de verdad que queramos.

Veamos un ejemplo sencillo e ilustrativo de fórmula verdadera y de fórmula falsa.

\begin{ejemplo}\label{ej:suma-binaria-logico-arreglado}
La fórmula \texttt{1+1=1} es verdadera en \textbf{SumaBinariaLógicoArreglado}, mientras que \texttt{1=1+1} es falsa.
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_verdadero
>>> es_verdadero('SumaBinariaLógicoArreglado', '1+1=1')
True
>>> es_verdadero('SumaBinariaLógicoArreglado', '1=1+1')
False
\end{lstlisting}
\end{ejemplo}
Al modificar la sintaxis, hemos logrado ``arreglar'' el sistema \textbf{SumaBinariaLógicoRoto}, como bien dice su nombre. En efecto, \textbf{SumaBinarioLógicoArreglado} es completo y sólido.

\begin{proposicion}
El sistema lógico \normalfont{\textbf{SumaBinariaLógicoArreglado}} es completo y sólido.
\end{proposicion}
\begin{proof}
Es sencillo ver que este sistema lógico es sólido. Basta ver que la regla (R1b) nos permite probar afirmaciones como \texttt{1+1=1}. Esta regla siempre añade más \texttt{1} a la izquierda de \texttt{=} que a la derecha. De este modo, en todo teorema del sistema la parte izquierda del igual será mayor o igual que la parte derecha, coincidiendo con la definición de la asignación de verdad (semántica).

La completitud de este sistema se prueba en la \cref{prop:ap-restr-arr}.
\end{proof}
A modo de resumen, vemos en la tabla siguiente la completitud y solidez de los sistemas presentados (junto con otra información que veremos más adelante).
% ====================
\begin{tabla}
\begin{table}[H]
\centering
\begin{tabular}{@{}lcccc@{}}
\cmidrule[0.7pt]{2-4}
 & Sólido & Completo & Decidible \\ \midrule
\textbf{SumaBinariaLógico} & sí & sí & sí \\
(reglas R1, R2, R3)\\[4pt]
\textbf{SumaBinariaLógicoRoto} & sí & no & sí \\
(reglas R1, R1b, R2, R3)\\[4pt]
\textbf{SumaBinariaLógicoRestringido} & no & sí & sí \\
(reglas R1, R2)\\[4pt]
\textbf{SumaBinariaLógicoArreglado} & sí & sí & sí \\
(reglas R1, R1b, R2, R3\\
y una semántica diferente)\\[4pt]
\textbf{AritméticaPeano} & asumido & no & no
\\ \bottomrule
\end{tabular}
\end{table}
\vspace{-8pt}
\caption{Solidez, completitud y decidibilidad de los sistemas lógicos de este capítulo}
\label{tab:sistemas-logicos}
\end{tabla}
% ====================
Adicionalmente a las propiedades de solidez y consistencia, podemos introducir una propiedad computacional: la de \emph{decidibilidad}. Ya sabemos qué significa \emph{decidible} para un problema de decisión: que podemos resolverlo con un programa que siempre para y tiene salida correcta. Para un sistema lógico $\mathcal{G}$ podemos definir un problema de decisión, $\textsc{EsVerdadero}_\mathcal{G}$.
\vspace{8pt}
\begin{problema}
\begin{framed}
$$\text{\textsc{EsVerdadero}}_\mathcal{G}$$

\begin{itemize}
    \item \textbf{Entrada:} una fórmula $\phi$ de $\mathcal{G}$.
    \item \textbf{Salida:} \palabra{sí} si $\mathcal{I}(\phi)$ está bien definido y $\mathcal{I}(\phi)=\text{verdadero}$, y \palabra{no} en caso contrario.
\end{itemize}
\end{framed}
\caption{$\text{\textsc{EsVerdadero}}_\mathcal{G}$}
\label{prob:es-verdadero}
\end{problema}

Para cada sistema lógico $\mathcal{G}$ obtenemos un problema de decisión distinto. Una vez definido este problema, es natural definir la decidibilidad de un sistema lógico mediante la decidibilidad del problema.

\begin{definicion}[Decidibilidad de un sistema lógico]\label{def:decidibilidad-sl}
\index{sistema lógico!decidible}\index{decidibilidad!de un sistema lógico}Decimos que un sistema lógico $\mathcal{G}$ es \emph{decidible} si el problema de decisión $\text{\textsc{EsVerdadero}}_\mathcal{G}$ es decidible.
\end{definicion}

De este modo, un sistema lógico es decidible si existe un programa que decide si una fórmula es verdadera o no. Es importante notar que algunos autores definen como sistema decidible aquel en el que el problema $\text{\textsc{EsTeorema}}_\mathcal{S}$ (que definimos a continuación) es decidible. Como hemos visto, la verdad y la demostración son conceptos diferentes, y nosotros nos referiremos siempre a la verdad al preguntarnos por si un sistema lógico es decidible.
\vspace{8pt}
\begin{problema}
\begin{framed}
$$\text{\textsc{EsTeorema}}_\mathcal{S}$$

\begin{itemize}
    \item \textbf{Entrada:} una fórmula $\phi$ de $\mathcal{S}$.
    \item \textbf{Salida:} \palabra{sí} si $\phi$ es un teorema de $\mathcal{S}$, y \palabra{no} en caso contrario.
\end{itemize}
\end{framed}
\caption{$\text{\textsc{EsTeorema}}_\mathcal{S}$}
\label{prob:es-teorema}
\end{problema}

Veamos si los sistemas lógicos que hemos introducido en este capítulo son decidibles. En el caso de \textbf{SumaBinariaLógico}, es sencillo crear un programa que sea capaz de comprobar si las fórmulas que se insertan están bien formadas, y que comprueba si la operación aritmética es correcta. De hecho, este programa está implementado: es la función \texttt{es\_verdadero} de \texttt{suma\_binaria.py}:
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_verdadero
>>> es_verdadero('SumaBinariaLógico', '1+1+1=11')
True
>>> es_verdadero('SumaBinariaLógico', '11+1=10')
False
\end{lstlisting}

En el caso del resto de sistemas lógicos, crear programas que los decidan resulta igual de sencillo. Las implementaciones a estos programas se encuentran igualmente en \texttt{es\_verdadero}. Vemos a continuación más ejemplos de la ejecución de esta función en el resto de sistemas lógicos.
\begin{lstlisting}[numbers=none,frame=none]
>>> from suma_binaria import es_verdadero
>>> es_verdadero('SumaBinariaLógico', '11=1+1')
False
>>> es_verdadero('SumaBinariaLógicoRoto', '11=1+1')
False
>>> es_verdadero('SumaBinariaLógicoRestringido', '11=1+1')
False
>>> es_verdadero('SumaBinariaLógicoArreglado', '11=1+1')
True
\end{lstlisting}


\section{La aritmética de Peano}\label{sec:aritmetica-peano}

Los sistemas lógicos que hemos explorado son de poca utilidad. Lo que queremos es trabajar con sistemas lógicos que permitan probar resultados interesantes en matemáticas. Los matemáticos, lógicos y filósofos han estudiado multitud de sistemas lógicos desde finales del siglo \texttt{xix}, pero dos destacan por su importancia: los \emph{axiomas de Zermelo-Fraenkel}, de teoría de conjuntos, y la \emph{aritmética de Peano}, de teoría de números. En este apartado nos centraremos en el último, pues la aritmética de Peano contiene fórmulas sobre enteros, adición, multiplicación, etc.

\index{aritmética de Peano}Llamaremos \textbf{Peano} al sistema lógico de la aritmética de Peano. Puedes encontrar la descripción completa de este sistema en el \cref{ap:peano}. En la \cref{fig:peano} puedes encontrar algunos detalles de tal descripción.
\vspace{8pt}
\begin{figure}[H]
\begin{framed}
La aritmética de Peano se compone de símbolos lógicos como $\forall$, $\exists$, $\vee$, $\wedge$, $\neg$, $=$, $\Rightarrow$ y $\iff$. Los axiomas y reglas de inferencia de \textbf{Peano} permiten deducir propiedades de los números naturales. Éstos se representan a partir del $0$ mediante la función sucesora $S$, de modo que $1$ es $S(0)$, $2$ es $S(S(0))$, etc. De forma general, $S(n)$ representa $n+1$ para un natural $n\in\mathbb{N}$.

Las reglas de inferencia incluyen fórmulas lógicas clásicas, tales como el \emph{modus ponens}: dado $a$ y $a\Rightarrow b$, podemos deducir $b$.
\end{framed}
\caption{Algunos detalles de \textbf{Peano}}
\label{fig:peano}
\end{figure}
En este sistema podemos producir fórmulas sobre aritmética muy interesantes. Vemos algunas de ellas a continuación.
\begin{ejemplo}\label{ej:formulas-peano}
Algunas fórmulas de \textbf{Peano} (expresadas en lenguaje natural):\footnote{Se pueden traducir sencillamente a aritmética de Peano. Por ejemplo, (F2) es $\forall x : x^2+1>0$, y (F6) es \linebreak $n>3 \wedge \neg \exists x,y,z : x^n+y^n=z^n$. Aunque las operaciones de comparación y exponenciación no estén inicialmente definidas en \textbf{Peano}, podemos definirlas mediante fórmulas del sistema.}
\begin{enumerate}[label=(PF\arabic*),wide = 0pt,widest={10}, leftmargin =*]
    \item $1+1=2$.
    \item Para todo entero $x$, es $x^2 + 1 > 0$.
    \item $2$ y $5$ son divisores de $30$.
    \item $13$ es primo.
    \item Sea $f(x)=x^2+1$. Entonces, $f^3(0)=5$.\footnote{$f^3$ significa iterar $f$ tres veces: $f^3(x)=f(f(f(x)))$.}
    \item Si $n>3$, no existen $x,y,z$ enteros tal que $x^n+y^n=z^n$ (el \emph{último teorema de Fermat}).
    \item Sea $f(x)=x+2$. Entonces, para todo entero positivo $y$ existe un entero positivo $x$ de modo que $f(x)=y$.
\end{enumerate}
\end{ejemplo}

Para poder trabajar con \textbf{Peano} en programas en Python, deberemos encontrar una forma de codificar los diversos símbolos, que especificamos en la \cref{tab:peano-string}.
% ====================
\begin{tabla}
\begin{table}[H]
\centering
\begin{tabular}{@{}ccl@{}}
\toprule
Símbolo & Codificación & Descripción \\ \midrule
$\neg(p)$ & \texttt{NO (p)} & Negación \\
$(p) \vee (q)$ & \texttt{(p) Ó (q)} & Disyunción \\
$\forall x : p$ & \texttt{PARA TODO (x) : (p)} & Cuantificador universal \\
$S(a)$ & \texttt{S(a)} & Sucesor \\
$\exists x : p$ & \texttt{EXISTE (x) : (p)} & Cuantificador existencial \\
$(p) \Rightarrow (q)$ & \texttt{(p)}\texttt{ }\texttt{=>}\texttt{ }\texttt{(q)} & Implicación \\
$(p) \iff (q)$ & \texttt{(p)}\texttt{ }\texttt{<=>}\texttt{ }\texttt{(q)} & Coimplicación \\
$(p)=(q)$ & \texttt{(p) = (q)} & Igualdad \\\bottomrule
\end{tabular}
\end{table}
\vspace{-8pt}
\caption{Una forma de traducir los símbolos de la aritmética de Peano a \emph{strings}}
\label{tab:peano-string}
\end{tabla}
% ====================
Por ejemplo, consideremos la afirmación ``no existen enteros $x$ e $y$ de modo que $2x=y$ e $y=3$'', que puede representarse en \textbf{Peano} como $\neg\exists x, y : S(S(0))*x = y \wedge y = S(S(S(0)))$ y que admite la siguiente codificación en \emph{string}:
\begin{lstlisting}[numbers=none,frame=none]
NO EXISTE x,y : S(S(0))*x = y Y y = S(S(S(0)))
\end{lstlisting}
Las fórmulas de \textbf{Peano}, por ser de un sistema lógico, pueden ser verdaderas o falsas. En el \cref{ej:formulas-peano}, las primeras seis fórmulas (de (PF1) a (PF6)) son verdaderas,\footnote{El último teorema de Fermat tiene especial relevancia histórica: fue formulado en 1637 y no fue resuelto hasta el año 1995 por Andrew Wiles. \cite{Wiles1995}} mientras que la última (la fórmula (PF7)) es falsa.

Para poder probar si una fórmula de \textbf{Peano} es verdadera, necesitamos que sea \emph{cerrada}: esto ocurre si todas sus variables son cuantificadas por un ``para todo'' ($\forall$) o un ``existe'' ($\exists$).\footnote{Recuerda que en la \cref{def:sistema-logico} dijimos que la asignación de verdad puede estar definida para un subconjunto de las fórmulas.} Un ejemplo de esto es $\forall x,y : x=y \wedge x+S(0)=y+S(0)$, que es una fórmula cerrada pues $x$ e $y$ son cuantificadas, mientras que $x=y \wedge x+S(0)=y+S(0)$ no es una fórmula cerrada. Esta distinción es importante porque, si una fórmula es cerrada, no podemos saber si es verdadera. Solo consideraremos fórmulas cerradas en \textbf{Peano} de aquí en adelante.

\vspace*{8pt}

Una vez que aceptamos que la aritmética de Peano puede expresar afirmaciones matemáticas como las del \cref{ej:formulas-peano}, podemos continuar para expresar las salidas de un programa en \textbf{Peano}. La siguiente proposición muestra cómo hacerlo para un conjunto concreto de fórmulas sobre los programas que necesitaremos más adelante. \cite{MacCormick2018}

\begin{proposicion}\label{prop:parada-a-peano}
Sea $P$ un programa de ordenador (o una máquina de Turing).\footnote{Probamos la equivalencia en el \cref{teo:equivalencia}.} La afirmación $H$ dada por
\begin{adjustwidth}{30pt}{}
    ``$P$ para con entrada vacía''
\end{adjustwidth}
puede ser traducida en una fórmula $\phi_H$ equivalente en \normalfont{\textbf{Peano}}. (En este caso, con ``equivalente'' nos referimos a que $H$ es verdadera si y solo si $\phi_H$ es verdadera.)
\end{proposicion}
\begin{proof}
Haremos un boceto de la prueba, dado que realizarla con un rigor estricto sería largo y tedioso.

En este caso, es más sencillo probar esto mediante máquinas de Turing. Recuerda que podemos definir cada momento de la ejecución de la máquina mediante una \emph{configuración}. En el caso de una máquina de Turing de una sola cinta, podemos codificar de forma sencilla una configuración cualquiera: podemos usar una codificación similar a la especificada en la \cref{prop:python-a-monocinta}, añadiendo el carácter \texttt{\^{}} para indicar la posición del cabezal. A modo de ejemplo, se especifica a continuación un ejemplo de codificación de una configuración del \cref{ej:mt-1}:
$$
q_R\;:\;X\:X\:\fbox{$X$}\:X\:a \;\;\;\; \longrightarrow \;\;\;\; \texttt{q\_R : X X \^{}X X a}
$$
Del mismo modo, podemos codificar los \emph{strings} mediante números en un \emph{string} binario (una palabra del alfabeto $\{\texttt{0}, \texttt{1}\}$. Así, es razonable asumir que la configuración de una máquina de Turing puede ser representada por un número en \emph{string} binario. La función de transición de la máquina de Turing toma una de estas configuraciones en binario como \emph{string} de entrada, y tiene como salida la nueva configuración, codificada de la misma forma. Desde este punto de vista, la función de transición es una función de enteros en enteros. Llamaremos a esta función $Paso$, dado que evaluar esta función una sola vez es equivalente a un paso de cálculo en la máquina de Turing. Observa que la función $Paso$ puede escribirse mediante aritmética de Peano: no es más que una función simple que depende de unos pocos bits de entrada.

Supongamos que $c_0$ es el entero que representa la configuración inicial de la máquina. Tras un paso de cálculo, la configuración de la máquina será $Paso(c_0)$, y tras dos pasos, será $Paso(Paso(c_0))$. Podemos abreviar esto como $Paso^2(c_0)$. Tras $n$ pasos, la configuración de la máquina será $Paso^n(c_0)$. Es importante destacar que cada una de las configuraciones puede ser expresada mediante aritmética de Peano.

Por otra parte, es evidente que la afirmación
\begin{adjustwidth}{30pt}{}
    ``$P$ para con entrada vacía''
\end{adjustwidth}
es equivalente a
\begin{adjustwidth}{30pt}{}
    ``Existe un natural $n$ de modo que $Paso^n(c_0)$ es una configuración de parada''
\end{adjustwidth}
Por ``configuración de parada''\index{configuración!de parada} nos referimos a que la máquina de Turing no puede seguir ejecutando transiciones: ha parado. Comprobar esto también es sencillo. Vamos a escribir una función $Parado$ que tiene como entrada un entero $m$ y como salida $0$ ó $1$. $Parado(m)=1$ si la configuración $m$ es de parada, y $Parado(m)=0$ en caso contrario.

Escribir esta función en \textbf{Peano} tampoco es difícil: ya en la \cref{def:proceso-calculo-maquina-turing} dijimos que una máquina para si no hay ninguna transición definida para la configuración en la que se encuentre. Es evidente que podemos traducir esta afirmación a una fórmula de la aritmética de Peano.

De este modo, hemos probado que $Parado(Paso^n(c_0))$ es una fórmula de \textbf{Peano} para un natural $n\in\mathbb{N}$ y un binario $c_0$. Por tanto, la afirmación:
\begin{adjustwidth}{30pt}{}
    ``Existe un natural $n$ de modo que $Parado(Paso^n(c_0))=1$''
\end{adjustwidth}
también puede traducirse a una fórmula de \textbf{Peano}. Esta afirmación es equivalente a las anteriores, y es esta fórmula justamente la $\phi_H$ que buscamos.
\end{proof}

De la prueba anterior, es evidente que la construcción de $\phi_H$ a partir de $H$ se realiza de una forma completamente algorítmica, que podría en principio ser implementada por un programa en Python. Sea tal programa \texttt{parada\_a\_peano.py}. En el código de este trabajo no se proporciona un programa que implemente esto, ya que hacerlo es una tarea compleja.\footnote{Existen repositorios de código que realizan esta tarea. Un ejemplo podemos encontrarlo en \cite{Henderson2013}.} Sin embargo, en el resto de este capítulo, importaremos la función \emph{main} \texttt{parada\_a\_peano} cuando sea necesario.

Definiremos a continuación dos problemas de decisión importantes: \textsc{EsTeoremaPeano} y \textsc{EsVerdaderoPeano}.\footnote{Observa que $\text{\textsc{EsTeoremaPeano}} = \text{\textsc{EsTeorema}}_\textbf{Peano}$ y $\text{\textsc{EsVerdaderoPeano}} = \text{\textsc{EsVerdadero}}_\textbf{Peano}$ (véanse los \cref{prob:es-teorema,prob:es-verdadero}).}
\vfill
\vspace{8pt}
% ====================
\begin{problema}
\begin{framed}
$$\text{\textsc{EsTeoremaPeano}}$$

\begin{itemize}
    \item \textbf{Entrada:} una fórmula $\phi$ de \textbf{Peano}.
    \item \textbf{Salida:} \palabra{sí} si $\phi$ es una fórmula bien formada y cerrada en \textbf{Peano}, y se trata de un teorema de \textbf{Peano}; \palabra{no} en caso contrario.
\end{itemize}
\end{framed}
\caption{\textsc{EsTeoremaPeano}}
\label{prob:es-teorema-peano}
\end{problema}
% ====================
\vfill
\pagebreak
% ====================
\begin{problema}
\begin{framed}
$$\text{\textsc{EsVerdaderoPeano}}$$

\begin{itemize}
    \item \textbf{Entrada:} una fórmula $\phi$ de \textbf{Peano}.
    \item \textbf{Salida:} \palabra{sí} si $\phi$ es una fórmula bien formada, cerrada y verdadera en \textbf{Peano}; \palabra{no} en caso contrario.
\end{itemize}
\end{framed}
\caption{\textsc{EsVerdaderoPeano}}
\label{prob:es-verdadero-peano}
\end{problema}
% ====================

Dada una afirmación $\phi$ en \textbf{Peano}, los problemas anteriores preguntan si $\phi$ es demostrable y/o verdadera. Resulta que ambos problemas son no decidibles. La no decidibilidad de \textsc{EsVerdaderoPeano} nos indica, mediante la \cref{def:decidibilidad-sl}, que \textbf{Peano} no es decidible (como ya adelantamos en la \cref{tab:sistemas-logicos}). \cite{MacCormick2018}

\begin{proposicion}\label{prop:es-verdadero-peano-no-decidible}
\normalfont{\textbf{Peano}} es no decidible.
\end{proposicion}
\begin{proof}
Procederemos mediante la reducción
$$\textsc{ParadaEnVacío}\;\text{(\cref{prob:parada-en-vacio})} \:\leq_T \textsc{EsVerdaderoPeano}.$$
Probaremos que esta reducción se implementa en el \cref{lst:parada-en-vacio-a-es-verdadero-peano}. La función \emph{main} (\cref{line:es-teorema-peano-main}) tiene como entrada un programa $P$. Usando la \cref{prop:parada-a-peano}, convertimos la afirmación $H=\text{``$P$ para con entrada vacía''}$ en una fórmula $\phi_H$ equivalente en la aritmética de Peano (\cref{line:parada-en-vacio-a-es-verdadero-peano-para-en-peano}). Es importante notar que \texttt{parada\_a\_peano} es una función computable, como comentamos anteriormente. Claramente, $P$ para si y solo si $\phi_H$ es verdadero, lo que demuestra la reducción. El resultado se sigue de la \cref{prop:decidible-reduccion}.
\end{proof}

\begin{lstlisting}[language=Python, caption=\lstinline{parada_en_vacio_a_es_verdadero_peano.py},label={lst:parada-en-vacio-a-es-verdadero-peano}]
from es_verdadero_peano import es_verdadero_peano # oráculo|\label{line:parada-en-vacio-a-es-verdadero-peano-es-verdadero-peano}|
from parada_a_peano import parada_a_peano # NO es un oráculo

def parada_en_vacio_a_es_verdadero_peano(programa):|\label{line:es-teorema-peano-main}|
    para_en_peano = parada_a_peano(programa)|\label{line:parada-en-vacio-a-es-verdadero-peano-para-en-peano}|
    return es_verdadero_peano(para_en_peano)
\end{lstlisting}

\begin{proposicion}\label{prop:es-teorema-peano-no-decidible}
\textsc{EsTeoremaPeano} es no decidible.
\end{proposicion}
\begin{proof}
De forma similar a la \cref{prop:es-verdadero-peano-no-decidible}, usaremos la reducción \linebreak $\textsc{ParadaEnVacío} \leq_T \textsc{EsVerdaderoPeano}$.

Antes de esto, debemos apreciar una propiedad de las afirmaciones de la forma \emph{``$P$ para con entrada vacía''}. Llamemos a tal afirmación $H(P)$,\footnote{Usamos $H$ del inglés \emph{halting}.} y mostraremos que para cualquier programa $P$, si $\phi_{H(P)}$ es verdadera en \textbf{Peano}, entonces es un teorema en \textbf{Peano}. Es importante notar que este no es el caso para todas las fórmulas (si no, \textbf{Peano} sería completo).

El motivo por el que esto ocurre justamente para las fórmulas $\phi_{H(P)}$ es porque, simplemente, debemos simular $P$ hasta que pare, algo que podemos definir mediante aritmética de Peano: simplemente calculamos $Parado(Paso^n(c_0))$ para cada $n\in\mathbb{N}$ de forma incremental, hasta que el resultado sea $1$.

Ahora podemos realizar la reducción usando el \cref{lst:parada-en-vacio-a-es-verdadero-peano} sustituyendo en la \cref{line:parada-en-vacio-a-es-verdadero-peano-es-verdadero-peano} a \texttt{es\_verdadero\_peano} por \texttt{es\_teorema\_peano}. Como las fórmulas verdaderas del tipo $\phi_{H(P)}$ son teoremas, la reducción es correcta.
\end{proof}

El caso de \textsc{EsTeoremaPeano} es menos grave, pues el problema es, de hecho, semidecidible (ver \cref{def:semidecidible}). Esto quiere decir que podemos escribir un programa que compruebe si una fórmula es un teorema (en caso de que la fórmula no sea un teorema, el programa no tiene por qué parar). \cite{MacCormick2018}

\begin{proposicion}\label{prop:es-teorema-peano-semidecidible}
\textsc{EsTeoremaPeano} es semidecidible.
\end{proposicion}
\begin{proof}
Es fácil ver que el \cref{lst:es-teorema-peano} hace a \textsc{EsTeoremaPeano} semidecidible. La idea es iterar sobre todos los posibles \emph{strings}, hasta ver si uno de ellos es una prueba de la fórmula de entrada.

En la \cref{line:es-teorema-peano-import} importamos la función \texttt{es\_prueba\_peano}, que dada una fórmula y una demostración en \textbf{Peano} comprueba si la demostración prueba que la fórmula es un teorema. Claramente, esta función no es un oráculo. De hecho, su implementación es sencilla: basta probar si cada una de las fórmulas de la demostración es un axioma o se sigue de las fórmulas anteriores a través de las reglas de inferencia del sistema, comprobando que la última fórmula coincida con la fórmula que queremos probar.

En el bucle de la \cref{line:es-teorema-peano-while} vamos iterando por todos los \emph{strings} para ver si son prueba de la fórmula \texttt{fórmula}. Estos \emph{strings} se enumeran en orden \emph{shortlex}: primero se enumeran en orden lexicográfico todos los \emph{strings} de longitud $1$, luego de longitud $2$, etc. Esta ordenación la proporciona la función \texttt{siguiente\_string} de \texttt{utilidades} (\cref{line:es-teorema-peano-siguiente-string}).

Si \texttt{fórmula} es un teorema, su demostración se encontrará eventualmente y el programa devolverá \texttt{sí}. En caso contrario, el programa no parará, pero esto no es un problema, ya que pretendemos mostrar la semidecibilidad del problema, la cual no requiere que el programa pare para instancias negativas.
\end{proof}

\begin{lstlisting}[language=Python, caption=\lstinline{es_teorema_peano.py},label={lst:es-teorema-peano}]
import utilidades
from es_prueba_peano import es_prueba_peano # NO es un oráculo|\label{line:es-teorema-peano-import}|

def es_teorema_peano(fórmula):|\label{line:es-teorema-peano-main}|
    demostración = ''|\label{line:es-teorema-peano-demostracion}|

    while True:|\label{line:es-teorema-peano-while}|
        if es_prueba_peano(demostración, fórmula) == 'sí':|\label{line:es-teorema-peano-es-prueba}|
            return 'sí'
        demostración = utilidades.siguiente_string(demostración)|\label{line:es-teorema-peano-siguiente-string}|
\end{lstlisting}

El hecho de que \textsc{EsTeoremaPeano} sea semidecidible es extremadamente importante, y se debe a una propiedad sintáctica de \textbf{Peano}: es recursivamente axiomatizable.

\begin{definicion}[Recursivamente axiomatizable]
\index{sistema formal!recursivamente axiomatizable}Un sistema formal $\mathcal{S}$ es \emph{recursivamente axiomatizable} si sus axiomas son recursivamente enumerables,\index{recursivamente enumerable} esto es, si existe un programa que enumera sus axiomas.\footnote{Si $\mathcal{S}$ es infinito, el programa correrá infinitamente.}
\end{definicion}

Decir que un sistema lógico $\mathcal{G}$ es recursivamente axiomatizable no es más que decir que el problema $\text{\textsc{EsTeorema}}_\mathcal{G}$ es semidecidible. Esta propiedad es fundamental para la prueba que realizaremos del Primer Teorema de Incompletitud (\cref{teo:incompletitud-peano}), pues si \textbf{Peano} no fuerse recursivamente axiomatizable, no podríamos usar la función \texttt{es\_teorema\_peano}.

El problema \textsc{EsTeorema} guarda una fuerte relación con el \emph{Entscheidungsproblem} (ver \cref{ch:historia}).\index{Entscheidungsproblem} Este problema pretende encontrar un algoritmo general que, dada una afirmación matemática, determine si es un teorema. Por la \cref{prop:es-teorema-peano-no-decidible}, \textsc{EsTeoremaPeano} es no decidible, lo cual prueba el \emph{Entscheidungsproblem} en el caso particular de la aritmética de Peano. El argumento que hemos realizado es similar al que hizo Turing en \cite{Turing1937}.

Finalmente, dado que \textbf{Peano} es un sistema lógico, nos podemos preguntar por su solidez y completitud. La pregunta sobre si \textbf{Peano} es completo es el objeto central de este trabajo, y se tratará en el \cref{ch:teorema-incompletitud}.

Preguntarnos por la solidez de \textbf{Peano} es una pregunta compleja. En este trabajo, asumiremos su solidez, dado que es razonable que los teoremas de \textbf{Peano} sean verdaderos.\footnote{Puedes ver tales axiomas en el \cref{ap:peano}.}

\section{Completitud sintáctica y consistencia}\label{sec:consistencia}

Los libros de lógica son extremadamente inconsistentes\footnote{Nótese la ironía.} al definir propiedades de sistemas lógicos (incluso al definir qué es un sistema formal y un sistema lógico). Por ahora, hemos definido las propiedades de solidez, completitud (semántica) y decidibilidad. Existe otra definición de completitud que depende únicamente de la sintaxis, y que por tanto es aplicable para sistemas formales. \cite{Kleene1971}

\begin{definicion}[Completitud sintáctica]\label{def:completitud-sintactica}
\index{sistema formal!sintácticamente completo}\index{sistema lógico!sintácticamente completo}\index{completitud!sintáctica}Sea $\mathcal{S}$ un sistema formal. Siempre que sea posible,\footnote{Es decir, que en el sistema formal esté bien definida la noción de \emph{negación} ($\neg$).} decimos que $\mathcal{S}$ es sintácticamente completo si, para toda fórmula $\phi$ de $\mathcal{S}$, es $\phi$ o $\neg\phi$ un teorema.\footnote{Es posible que tanto $\phi$ como $\neg\phi$ sean teoremas.}
\end{definicion}

Observa que, para que esta definición sea posible, es necesario que en el sistema formal esté bien definida la noción de \emph{negación}. Esto se traduce a que el sistema sea una \emph{lógica de primer orden}. Definir este concepto de forma exacta queda fuera del alcance de este trabajo. Simplemente notaremos que los sistemas lógicos suficientemente expresivos, como la aritmética de Peano o los axiomas de Zermelo-Fraenkl,\index{axiomas de Zermelo-Fraenkl} son de este tipo.

Para esta clase de sistemas también es posible definir una nueva propiedad: la \emph{consistencia}. Nuevamente, podemos definir dos tipos de consistencia, una sintáctica y una semántica.

\begin{definicion}[Consistencia sintáctica]\label{def:consistencia-sintactica}
\index{sistema formal!sintácticamente consistente}\index{sistema lógico!sintácticamente consistente}\index{consistencia!sintáctica}Sea $\mathcal{S}$ un sistema formal. Siempre que sea posible, decimos que $\mathcal{S}$ es \emph{sintácticamente completo} si, para toda fórmula $\phi$ de $\mathcal{S}$, no es posible que tanto $\phi$ como $\neg\phi$ sean teoremas.
\end{definicion}

\begin{definicion}[Consistencia semántica]\label{def:consistencia-semantica}
\index{sistema lógico!semánticamente consistente}\index{consistencia!semántica}Sea $\mathcal{G}$ un sistema lógico. Siempre que sea posible, decimos que $\mathcal{G}$ es \emph{semánticamente completo} si, para toda fórmula $\phi$ de $\mathcal{G}$, no es posible que tanto $\phi$ como $\neg\phi$ sean verdaderas.
\end{definicion}

En otras palabras, un sistema es consistente si no da lugar a demostraciones o a verdades contradictorias. En un sistema sólido y completo, una fórmula es consistente sintácticamente si y solo si lo es semánticamente.

Es importante hacer una apreciación respecto a las definiciones de completitud y consistencia sintácticas: a pesar de que las definimos para sistemas formales, es sencillo extender esta definición a sistemas lógicos, teniendo en cuenta su sintaxis.

De este modo, decimos que un sistema lógico $\mathcal{G}$ es sintácticamente completo si, dada una fórmula $\phi$ de $\mathcal{G}$, $\phi$ o $\neg\phi$ son teoremas. Análogamente, $\mathcal{G}$ es sintácticamente consistente si no es posible que tanto $\phi$ como $\neg\phi$ sean teoremas.

Las definiciones que hemos hecho hasta este punto (sin incluir la de decidibilidad) se encuentran resumidas en la \cref{fig:definiciones-logica}.

\vfill
% ====================
\begin{figure}[H]
\centering
\vspace{8pt}
$$\text{sean }\mathcal{G}\text{ sistema lógico, }\phi \text{ fórmula de }\mathcal{G}$$
$$
\begin{matrix}
\mathcal{G}\text{ sólido} & \;\;\;:\;\;\; & \phi\text{ teorema}\Rightarrow\phi\text{ verdadero}\\
\text{\small{(\cref{def:solidez})}}\\[4pt]
\mathcal{G}\text{ (semánticamente) completo} & : & \phi\text{ verdadero}\Rightarrow\phi\text{ teorema}\\
\text{\small{(\cref{def:completitud})}}\\[4pt]
\mathcal{G}\text{ sintácticamente completo*} & : & \phi\text{ o }\neg\phi\text{ son teoremas}\\
\text{\small{(\cref{def:completitud-sintactica})}}\\[4pt]
\mathcal{G}\text{ sintácticamente consistente*} & : & \text{no son }\phi\text{ y }\neg\phi\text{ teoremas}\\
\text{\small{(\cref{def:consistencia-sintactica})}}\\[4pt]
\mathcal{G}\text{ semánticamente consistente} & : & \text{no son }\phi\text{ y }\neg\phi\text{ verdaderos}\\
\text{\small{(\cref{def:consistencia-semantica})}}\\[4pt]
\end{matrix}
$$
$$\text{\small{*definición también aplicable a sistemas formales}}$$
\caption{Algunas de las propiedades de los sistemas lógicos definidos en este capítulo}
\label{fig:definiciones-logica}
\end{figure}
% ====================
\vfill
\endinput
